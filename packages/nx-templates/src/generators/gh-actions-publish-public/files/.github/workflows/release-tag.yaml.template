# Create a github release for the given tag passed in as an input
#
# Note that you should pass `secrets: inherit` when calling this workflow
# as it consumes `secrets.GITHUB_TOKEN` to create the release.
# (See: https://docs.github.com/en/actions/using-workflows/reusing-workflows#using-inputs-and-secrets-in-a-reusable-workflow)

name: Add GitHub Release Tag

on:
  workflow_call:
    inputs:
      tag:
        description: "The tag to release"
        required: true
        type: string
      commit_hash:
        description: "The commit hash that changelog generation occurs from"
        required: true
        type: string
      organization:
        description: "The organization that the repo belongs to"
        required: true
        type: string
      repo:
        description: "The repo to release"
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Set-up git user
      - name: Set-up git user
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # Sync the source to the latest commit
      - name: Sync source
        run: |
          set -e
          git fetch --unshallow
          git pull

      # Get the package name from the tag
      - name: Get pkgName for tag
        id: tag
        env:
          tag: ${{ inputs.tag }}
        run: |
          # Exit on error
          set -e

          echo "Tag received: $tag"

          # `%@*` truncates @ and version number from the right side.
          # https://stackoverflow.com/questions/9532654/expression-after-last-specific-character
          pkgName=${tag%@*}

          # Find all package.json files in the repo, excluding those in node_modules
          pkgJsons=$(find . -type d -name "node_modules" -prune -o -type f -name "package.json" | grep -v "node_modules")

          # Find for package.json files that match the tag
          pkgJsonPath=""

          for pkgJson in $pkgJsons; do
            # Get the package name from the package.json file
            name=$(cat "$pkgJson" | jq -r '.name')

            # If the package name matches the tag, then set the pkgName to the package name
            if [[ "$name" == "$pkgName" ]]; then
              pkgJsonPath="$pkgJson"
              # This line removes the leading "./" from the path
              pkgJsonPath="${pkgJsonPath#./}"
              # This line removes the trailing "/package.json" from the path
              pkgJsonPath="${pkgJsonPath%/package.json}"
              break
            fi
          done

          # If no package.json file was found, then exit with an error
          if [[ -z $pkgJsonPath ]]; then
            echo "No package.json file found for tag $tag"
            exit 1
          fi

          # Export the pkgName and pkgJsonPath variables
          echo "pkgJsonPath=$pkgJsonPath" >> $GITHUB_OUTPUT

      # Create a GitHub Release for the tag
      - name: Create Release for Tag
        id: release_tag
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          release_name: ${{ inputs.tag }}
          tag_name: ${{ inputs.tag }}
          draft: false
          body: |
            Please refer to [CHANGELOG.md](https://github.com/${{ inputs.organization }}/${{ inputs.repo }}/blob/${{ inputs.commit_hash }}/${{ steps.tag.outputs.pkgJsonPath }}/CHANGELOG.md) for details.
